<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Arcade Machine - ZebratronGameSystem</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            max-width: 300px;
        }
        
        h1 {
            color: #00ff88;
            margin-top: 0;
            text-shadow: 0 0 10px #00ff88;
        }
        
        button {
            background: #006600;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            margin: 5px;
        }
        
        button:hover {
            background: #008800;
        }
        
        .controls {
            margin-top: 10px;
        }
        
        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            max-width: 250px;
            font-size: 12px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h1>üïπÔ∏è 3D Arcade</h1>
            <div class="controls">
                <button onclick="loadHambert()">üêπ Load Hambert</button>
                <button onclick="loadZSynth()">üéπ Load Z-Synth</button>
                <br>
                <button onclick="startGame()">‚ñ∂Ô∏è Start</button>
                <button onclick="stopGame()">‚è∏Ô∏è Stop</button>
                <button onclick="resetGame()">üîÑ Reset</button>
            </div>
            <div class="status" id="status">Loading...</div>
        </div>
        
        <div id="instructions">
            <strong>üéÆ Controls:</strong><br>
            ‚Ä¢ Mouse: Rotate view<br>
            ‚Ä¢ Scroll: Zoom in/out<br>
            ‚Ä¢ Arrow keys: Game input<br>
            ‚Ä¢ ZSXDCVGBHNJM: Z-Synth keys
        </div>
    </div>

    <!-- Three.js from CDN using older version that supports global scripts -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>

    <!-- ZGS System -->
    <script type="module">
        // Import ZGS
        import init, { ZebratronCartridgeSystem as WasmCartridgeSystem } from './pkg/zebratron_core.js';
        import { AudioManager } from './src/audio.js';
        
        // Global variables
        let scene, camera, renderer, controls, arcadeMachine, screenTexture;
        let zgsSystem = null;
        let audioManager = null;
        let isRunning = false;
        let currentCartridge = null;
        let activeKeys = new Set();

        // ZGS Wrapper class
        class ZebratronCartridgeSystem {
            constructor() {
                this.wasmSystem = null;
                this.canvas = null;
                this.ctx = null;
                this.audioManager = null;
                this.isInitialized = false;
            }

            async initialize(canvasElement) {
                if (this.isInitialized) return;

                await init();
                this.wasmSystem = new WasmCartridgeSystem();

                if (canvasElement) {
                    this.canvas = canvasElement;
                    this.ctx = canvasElement.getContext('2d');
                    canvasElement.width = 320;
                    canvasElement.height = 240;
                }

                this.audioManager = new AudioManager();
                await this.audioManager.initialize();
                this.audioManager.connectSystem(this.wasmSystem);

                this.isInitialized = true;
            }

            loadHambertCartridge() {
                return this.wasmSystem ? this.wasmSystem.load_hambert_cartridge() : false;
            }

            loadZSynthCartridge() {
                return this.wasmSystem ? this.wasmSystem.load_zsynth_cartridge() : false;
            }

            async start() {
                if (this.wasmSystem) {
                    this.wasmSystem.start();
                    if (this.audioManager) {
                        await this.audioManager.start();
                        this.audioManager.connectSystem(this.wasmSystem);
                    }
                }
            }

            stop() {
                if (this.wasmSystem) this.wasmSystem.stop();
                if (this.audioManager) this.audioManager.stop();
            }

            reset() {
                if (this.wasmSystem) this.wasmSystem.reset();
            }

            stepFrame() {
                return this.wasmSystem ? this.wasmSystem.step_frame() : false;
            }

            render() {
                if (this.wasmSystem) this.wasmSystem.render();
            }

            get_screen_buffer() {
                return this.wasmSystem ? this.wasmSystem.get_screen_buffer() : null;
            }

            handleInput(up, down, left, right) {
                if (this.wasmSystem) this.wasmSystem.handle_input(up, down, left, right);
            }

            handleZSynthKeyDown(key) {
                if (this.wasmSystem) this.wasmSystem.handle_zsynth_key_down(key);
            }

            handleZSynthKeyUp(key) {
                if (this.wasmSystem) this.wasmSystem.handle_zsynth_key_up(key);
            }
        }

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.2, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0x00ff88, 1, 10, Math.PI / 4, 0.5);
            spotLight.position.set(0, 4, 2);
            spotLight.castShadow = true;
            scene.add(spotLight);

            const screenLight = new THREE.PointLight(0x4488ff, 0.8, 5);
            screenLight.position.set(0, 1.2, 0.5);
            scene.add(screenLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            window.addEventListener('resize', onWindowResize, false);
        }

        // Create arcade machine
        function createArcadeMachine() {
            arcadeMachine = new THREE.Group();

            // Main cabinet
            const cabinetGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.6);
            const cabinetMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
            cabinet.position.y = 0.9;
            cabinet.castShadow = true;
            arcadeMachine.add(cabinet);

            // Screen bezel
            const bezelGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.05);
            const bezelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const bezel = new THREE.Mesh(bezelGeometry, bezelMaterial);
            bezel.position.set(0, 1.3, 0.3);
            arcadeMachine.add(bezel);

            // Screen texture
            const screenData = new Uint8Array(320 * 240 * 4);
            for (let i = 0; i < screenData.length; i += 4) {
                screenData[i] = 0; screenData[i + 1] = 0; screenData[i + 2] = 64; screenData[i + 3] = 255;
            }

            screenTexture = new THREE.DataTexture(screenData, 320, 240, THREE.RGBAFormat);
            screenTexture.flipY = true;
            screenTexture.magFilter = THREE.NearestFilter;
            screenTexture.minFilter = THREE.NearestFilter;

            // Screen
            const screenGeometry = new THREE.PlaneGeometry(0.4, 0.3);
            const screenMaterial = new THREE.MeshBasicMaterial({ 
                map: screenTexture,
                emissive: new THREE.Color(0x002244)
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 1.3, 0.325);
            arcadeMachine.add(screen);

            // Control panel
            const controlGeometry = new THREE.BoxGeometry(0.7, 0.1, 0.3);
            const controlMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const controlPanel = new THREE.Mesh(controlGeometry, controlMaterial);
            controlPanel.position.set(0, 1.0, 0.15);
            controlPanel.rotation.x = -0.2;
            arcadeMachine.add(controlPanel);

            // Joystick
            const stickGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.15);
            const stickMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const joystick = new THREE.Mesh(stickGeometry, stickMaterial);
            joystick.position.set(-0.15, 1.12, 0.05);
            arcadeMachine.add(joystick);

            // Buttons
            const buttonGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.02);
            const buttonMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            
            for (let i = 0; i < 6; i++) {
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(0.05 + (i % 3) * 0.08, 1.08, 0.05 + Math.floor(i / 3) * 0.08);
                arcadeMachine.add(button);
            }

            // Marquee
            const marqueeGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.03);
            const marqueeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff88 });
            const marquee = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
            marquee.position.set(0, 1.7, 0.3);
            arcadeMachine.add(marquee);

            scene.add(arcadeMachine);
        }

        // Initialize ZGS
        async function initializeZGS() {
            try {
                updateStatus('Initializing system...');
                zgsSystem = new ZebratronCartridgeSystem();
                
                const virtualCanvas = document.createElement('canvas');
                virtualCanvas.width = 320;
                virtualCanvas.height = 240;
                
                await zgsSystem.initialize(virtualCanvas);
                updateStatus('System ready - Load a cartridge');
            } catch (error) {
                console.error('Failed to initialize ZGS:', error);
                updateStatus('Failed to initialize system');
            }
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (isRunning && zgsSystem) {
                try {
                    const frameReady = zgsSystem.stepFrame();
                    if (frameReady) {
                        zgsSystem.render();
                        
                        const buffer = zgsSystem.get_screen_buffer();
                        if (buffer && screenTexture) {
                            screenTexture.image.data = new Uint8Array(buffer);
                            screenTexture.needsUpdate = true;
                        }
                    }
                } catch (error) {
                    console.error('Game loop error:', error);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Event handlers
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Global functions for buttons (expose to window)
        globalThis.loadHambert = function() {
            if (!zgsSystem) return;
            try {
                const success = zgsSystem.loadHambertCartridge();
                if (success) {
                    currentCartridge = 'hambert';
                    updateStatus('Hambert loaded - Use arrow keys');
                }
            } catch (error) {
                console.error('Error loading Hambert:', error);
            }
        }

        globalThis.loadZSynth = function() {
            if (!zgsSystem) return;
            try {
                const success = zgsSystem.loadZSynthCartridge();
                if (success) {
                    currentCartridge = 'zsynth';
                    updateStatus('Z-Synth loaded - Use ZSXDCVGBHNJM keys');
                }
            } catch (error) {
                console.error('Error loading Z-Synth:', error);
            }
        }

        globalThis.startGame = async function() {
            if (isRunning || !zgsSystem) return;
            try {
                await zgsSystem.start();
                isRunning = true;
                updateStatus('Running - Enjoy the 3D arcade!');
            } catch (error) {
                console.error('Failed to start:', error);
            }
        }

        globalThis.stopGame = function() {
            isRunning = false;
            if (zgsSystem) zgsSystem.stop();
            updateStatus('Stopped');
            activeKeys.clear();
        }

        globalThis.resetGame = function() {
            if (zgsSystem) {
                zgsSystem.reset();
                updateStatus('Reset');
            }
        }

        // Keyboard handling
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Game controls
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key) && currentCartridge === 'hambert') {
                handleGameInput(event);
                event.preventDefault();
            }
            
            // Z-Synth controls
            const synthKeys = 'zsxdcvgbhnjm';
            if (synthKeys.includes(key) && currentCartridge === 'zsynth' && zgsSystem) {
                if (!activeKeys.has(key)) {
                    activeKeys.add(key);
                    zgsSystem.handleZSynthKeyDown(key);
                }
                event.preventDefault();
            }
        });

        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            
            // Game controls
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key) && currentCartridge === 'hambert') {
                handleGameInput(event);
                event.preventDefault();
            }
            
            // Z-Synth controls
            const synthKeys = 'zsxdcvgbhnjm';
            if (synthKeys.includes(key) && currentCartridge === 'zsynth' && zgsSystem) {
                if (activeKeys.has(key)) {
                    activeKeys.delete(key);
                    zgsSystem.handleZSynthKeyUp(key);
                }
                event.preventDefault();
            }
        });

        function handleGameInput(event) {
            if (!zgsSystem) return;
            
            // Simple key state tracking
            const up = event.key === 'ArrowUp' && event.type === 'keydown';
            const down = event.key === 'ArrowDown' && event.type === 'keydown';
            const left = event.key === 'ArrowLeft' && event.type === 'keydown';
            const right = event.key === 'ArrowRight' && event.type === 'keydown';
            
            zgsSystem.handleInput(up, down, left, right);
        }

        // Initialize everything
        initThreeJS();
        createArcadeMachine();
        initializeZGS();
        animate();

    </script>
</body>
</html>