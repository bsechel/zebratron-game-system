<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Arcade Machine - ZebratronGameSystem</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            max-width: 300px;
        }
        
        h1 {
            color: #00ff88;
            margin-top: 0;
            text-shadow: 0 0 10px #00ff88;
        }
        
        button {
            background: #006600;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            margin: 5px;
        }
        
        button:hover {
            background: #008800;
        }
        
        .controls {
            margin-top: 10px;
        }
        
        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            max-width: 250px;
            font-size: 12px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h1>üïπÔ∏è 3D Arcade</h1>
            <div class="controls">
                <button onclick="loadHambert()">üêπ Load Hambert</button>
                <button onclick="loadZSynth()">üéπ Load Z-Synth</button>
                <br>
                <button onclick="startGame()">‚ñ∂Ô∏è Start</button>
                <button onclick="stopGame()">‚è∏Ô∏è Stop</button>
                <button onclick="resetGame()">üîÑ Reset</button>
            </div>
            <div class="status" id="status">Loading...</div>
        </div>
        
        <div id="instructions">
            <strong>üéÆ Controls:</strong><br>
            ‚Ä¢ Mouse: Rotate view<br>
            ‚Ä¢ Scroll: Zoom in/out<br>
            ‚Ä¢ Arrow keys: Game input<br>
            ‚Ä¢ ZSXDCVGBHNJM: Z-Synth keys
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script>
        // Inline OrbitControls to ensure it works
        (function() {
            function OrbitControls( object, domElement ) {
                if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
                if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );
                
                this.object = object;
                this.domElement = domElement;
                this.domElement.style.touchAction = 'none';
                
                this.enabled = true;
                this.target = new THREE.Vector3();
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.minZoom = 0;
                this.maxZoom = Infinity;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.minAzimuthAngle = - Infinity;
                this.maxAzimuthAngle = Infinity;
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = true;
                this.panSpeed = 1.0;
                this.screenSpacePanning = true;
                this.keyPanSpeed = 7.0;
                this.autoRotate = false;
                this.autoRotateSpeed = 2.0;
                this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };
                this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
                this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                
                var scope = this;
                var changeEvent = { type: 'change' };
                var startEvent = { type: 'start' };
                var endEvent = { type: 'end' };
                var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
                var state = STATE.NONE;
                var EPS = 0.000001;
                var spherical = new THREE.Spherical();
                var sphericalDelta = new THREE.Spherical();
                var scale = 1;
                var panOffset = new THREE.Vector3();
                var zoomChanged = false;
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();
                
                function getAutoRotationAngle() { return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed; }
                function getZoomScale() { return Math.pow( 0.95, scope.zoomSpeed ); }
                
                function rotateLeft( angle ) { sphericalDelta.theta -= angle; }
                function rotateUp( angle ) { sphericalDelta.phi -= angle; }
                
                var panLeft = function() {
                    var v = new THREE.Vector3();
                    return function panLeft( distance, objectMatrix ) {
                        v.setFromMatrixColumn( objectMatrix, 0 );
                        v.multiplyScalar( - distance );
                        panOffset.add( v );
                    };
                }();
                
                var panUp = function() {
                    var v = new THREE.Vector3();
                    return function panUp( distance, objectMatrix ) {
                        if ( scope.screenSpacePanning === true ) {
                            v.setFromMatrixColumn( objectMatrix, 1 );
                        } else {
                            v.setFromMatrixColumn( objectMatrix, 0 );
                            v.crossVectors( scope.object.up, v );
                        }
                        v.multiplyScalar( distance );
                        panOffset.add( v );
                    };
                }();
                
                var pan = function() {
                    var offset = new THREE.Vector3();
                    return function pan( deltaX, deltaY ) {
                        var element = scope.domElement;
                        if ( scope.object.isPerspectiveCamera ) {
                            var position = scope.object.position;
                            offset.copy( position ).sub( scope.target );
                            var targetDistance = offset.length();
                            targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );
                            panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                            panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );
                        } else if ( scope.object.isOrthographicCamera ) {
                            panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                            panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );
                        } else {
                            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                            scope.enablePan = false;
                        }
                    };
                }();
                
                function dollyOut( dollyScale ) {
                    if ( scope.object.isPerspectiveCamera ) {
                        scale /= dollyScale;
                    } else if ( scope.object.isOrthographicCamera ) {
                        scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
                        scope.object.updateProjectionMatrix();
                        zoomChanged = true;
                    } else {
                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                        scope.enableZoom = false;
                    }
                }
                
                function dollyIn( dollyScale ) {
                    if ( scope.object.isPerspectiveCamera ) {
                        scale *= dollyScale;
                    } else if ( scope.object.isOrthographicCamera ) {
                        scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
                        scope.object.updateProjectionMatrix();
                        zoomChanged = true;
                    } else {
                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                        scope.enableZoom = false;
                    }
                }
                
                function handleMouseDownRotate( event ) {
                    rotateStart.set( event.clientX, event.clientY );
                }
                
                function handleMouseDownDolly( event ) {
                    dollyStart.set( event.clientX, event.clientY );
                }
                
                function handleMouseDownPan( event ) {
                    panStart.set( event.clientX, event.clientY );
                }
                
                function handleMouseMoveRotate( event ) {
                    rotateEnd.set( event.clientX, event.clientY );
                    rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
                    var element = scope.domElement;
                    rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight );
                    rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
                    rotateStart.copy( rotateEnd );
                    scope.update();
                }
                
                function handleMouseMoveDolly( event ) {
                    dollyEnd.set( event.clientX, event.clientY );
                    dollyDelta.subVectors( dollyEnd, dollyStart );
                    if ( dollyDelta.y > 0 ) {
                        dollyOut( getZoomScale() );
                    } else if ( dollyDelta.y < 0 ) {
                        dollyIn( getZoomScale() );
                    }
                    dollyStart.copy( dollyEnd );
                    scope.update();
                }
                
                function handleMouseMovePan( event ) {
                    panEnd.set( event.clientX, event.clientY );
                    panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
                    pan( panDelta.x, panDelta.y );
                    panStart.copy( panEnd );
                    scope.update();
                }
                
                function handleMouseWheel( event ) {
                    if ( event.deltaY < 0 ) {
                        dollyIn( getZoomScale() );
                    } else if ( event.deltaY > 0 ) {
                        dollyOut( getZoomScale() );
                    }
                    scope.update();
                }
                
                function onMouseDown( event ) {
                    if ( scope.enabled === false ) return;
                    event.preventDefault();
                    scope.domElement.focus ? scope.domElement.focus() : window.focus();
                    
                    if ( event.button === 0 ) {
                        if ( scope.enableRotate === false ) return;
                        handleMouseDownRotate( event );
                        state = STATE.ROTATE;
                    } else if ( event.button === 1 ) {
                        if ( scope.enableZoom === false ) return;
                        handleMouseDownDolly( event );
                        state = STATE.DOLLY;
                    } else if ( event.button === 2 ) {
                        if ( scope.enablePan === false ) return;
                        handleMouseDownPan( event );
                        state = STATE.PAN;
                    }
                    
                    if ( state !== STATE.NONE ) {
                        scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
                        scope.domElement.addEventListener( 'mouseup', onMouseUp, false );
                        scope.dispatchEvent( startEvent );
                    }
                }
                
                function onMouseMove( event ) {
                    if ( scope.enabled === false ) return;
                    event.preventDefault();
                    
                    if ( state === STATE.ROTATE ) {
                        if ( scope.enableRotate === false ) return;
                        handleMouseMoveRotate( event );
                    } else if ( state === STATE.DOLLY ) {
                        if ( scope.enableZoom === false ) return;
                        handleMouseMoveDolly( event );
                    } else if ( state === STATE.PAN ) {
                        if ( scope.enablePan === false ) return;
                        handleMouseMovePan( event );
                    }
                }
                
                function onMouseUp( event ) {
                    if ( scope.enabled === false ) return;
                    scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
                    scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );
                    scope.dispatchEvent( endEvent );
                    state = STATE.NONE;
                }
                
                function onMouseWheel( event ) {
                    if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;
                    event.preventDefault();
                    event.stopPropagation();
                    scope.dispatchEvent( startEvent );
                    handleMouseWheel( event );
                    scope.dispatchEvent( endEvent );
                }
                
                this.update = function() {
                    var offset = new THREE.Vector3();
                    var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
                    var quatInverse = quat.clone().invert();
                    var lastPosition = new THREE.Vector3();
                    var lastQuaternion = new THREE.Quaternion();
                    
                    return function update() {
                        var position = scope.object.position;
                        offset.copy( position ).sub( scope.target );
                        offset.applyQuaternion( quat );
                        spherical.setFromVector3( offset );
                        if ( scope.autoRotate && state === STATE.NONE ) {
                            rotateLeft( getAutoRotationAngle() );
                        }
                        if ( scope.enableDamping === true ) {
                            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                        } else {
                            spherical.theta += sphericalDelta.theta;
                            spherical.phi += sphericalDelta.phi;
                        }
                        spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );
                        spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
                        spherical.makeSafe();
                        spherical.radius *= scale;
                        spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );
                        if ( scope.enableDamping === true ) {
                            scope.target.addScaledVector( panOffset, scope.dampingFactor );
                        } else {
                            scope.target.add( panOffset );
                        }
                        offset.setFromSpherical( spherical );
                        offset.applyQuaternion( quatInverse );
                        position.copy( scope.target ).add( offset );
                        scope.object.lookAt( scope.target );
                        if ( scope.enableDamping === true ) {
                            sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                            sphericalDelta.phi *= ( 1 - scope.dampingFactor );
                            panOffset.multiplyScalar( 1 - scope.dampingFactor );
                        } else {
                            sphericalDelta.set( 0, 0, 0 );
                            panOffset.set( 0, 0, 0 );
                        }
                        scale = 1;
                        if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {
                            scope.dispatchEvent( changeEvent );
                            lastPosition.copy( scope.object.position );
                            lastQuaternion.copy( scope.object.quaternion );
                            zoomChanged = false;
                            return true;
                        }
                        return false;
                    };
                }();
                
                this.dispose = function() {
                    scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
                    scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
                    scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );
                };
                
                function onContextMenu( event ) {
                    if ( scope.enabled === false ) return;
                    event.preventDefault();
                }
                
                scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );
                scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
                scope.domElement.addEventListener( 'wheel', onMouseWheel, false );
                this.update();
            }
            
            OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
            OrbitControls.prototype.constructor = OrbitControls;
            
            THREE.OrbitControls = OrbitControls;
        })();
    </script>

    <!-- ZGS Integration -->
    <script type="module">
        // Import ZGS modules
        import init, { ZebratronCartridgeSystem as WasmCartridgeSystem } from './pkg/zebratron_core.js';
        
        // Simple AudioManager class (inlined to avoid import issues)
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.gainNode = null;
                this.scriptProcessor = null;
                this.isInitialized = false;
                this.isPlaying = false;
            }

            async initialize() {
                if (this.isInitialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    this.gainNode.connect(this.audioContext.destination);
                    this.scriptProcessor = this.audioContext.createScriptProcessor(1024, 0, 1);
                    this.scriptProcessor.connect(this.gainNode);
                    this.isInitialized = true;
                    console.log('üéµ Audio system initialized');
                } catch (error) {
                    console.error('Failed to initialize audio:', error);
                }
            }

            connectSystem(system) {
                if (!this.isInitialized || !this.scriptProcessor) return;
                try {
                    const testSample = system.generate_audio_sample();
                    console.log('‚úÖ Audio connected to APU');
                    this.scriptProcessor.onaudioprocess = (event) => {
                        const outputBuffer = event.outputBuffer;
                        const outputData = outputBuffer.getChannelData(0);
                        for (let i = 0; i < outputBuffer.length; i++) {
                            try {
                                outputData[i] = system.generate_audio_sample();
                            } catch (error) {
                                outputData[i] = 0;
                            }
                        }
                    };
                } catch (error) {
                    console.warn('APU audio not available, using silent mode');
                }
            }

            async start() {
                if (!this.isInitialized) return;
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                this.isPlaying = true;
                console.log('üîä Audio started');
            }

            stop() {
                this.isPlaying = false;
                console.log('üîá Audio stopped');
            }
        }
        
        // ZGS Wrapper class
        class ZebratronCartridgeSystem {
            constructor() {
                this.wasmSystem = null;
                this.audioManager = null;
                this.isInitialized = false;
            }

            async initialize() {
                if (this.isInitialized) return;

                await init();
                this.wasmSystem = new WasmCartridgeSystem();

                this.audioManager = new AudioManager();
                await this.audioManager.initialize();
                this.audioManager.connectSystem(this.wasmSystem);

                this.isInitialized = true;
            }

            loadHambertCartridge() {
                return this.wasmSystem ? this.wasmSystem.load_hambert_cartridge() : false;
            }

            loadZSynthCartridge() {
                return this.wasmSystem ? this.wasmSystem.load_zsynth_cartridge() : false;
            }

            async start() {
                if (this.wasmSystem) {
                    this.wasmSystem.start();
                    if (this.audioManager) {
                        await this.audioManager.start();
                        this.audioManager.connectSystem(this.wasmSystem);
                    }
                }
            }

            stop() {
                if (this.wasmSystem) this.wasmSystem.stop();
                if (this.audioManager) this.audioManager.stop();
            }

            reset() {
                if (this.wasmSystem) this.wasmSystem.reset();
            }

            stepFrame() {
                return this.wasmSystem ? this.wasmSystem.step_frame() : false;
            }

            render() {
                if (this.wasmSystem) this.wasmSystem.render();
            }

            get_screen_buffer() {
                return this.wasmSystem ? this.wasmSystem.get_screen_buffer() : null;
            }

            handleInput(up, down, left, right) {
                if (this.wasmSystem) this.wasmSystem.handle_input(up, down, left, right);
            }

            handleZSynthKeyDown(key) {
                if (this.wasmSystem) this.wasmSystem.handle_zsynth_key_down(key);
            }

            handleZSynthKeyUp(key) {
                if (this.wasmSystem) this.wasmSystem.handle_zsynth_key_up(key);
            }

            getCurrentCartridgeType() {
                return this.wasmSystem ? this.wasmSystem.get_current_cartridge_type() : 0;
            }
        }

        // Expose ZGS to global scope and initialize immediately
        window.createZGSSystem = async function() {
            const system = new ZebratronCartridgeSystem();
            await system.initialize();
            return system;
        };
        
        // Mark module as loaded
        window.zgsModuleLoaded = true;
    </script>

    <!-- Global variables and functions (non-module) -->
    <script>
        // Global variables
        let scene, camera, renderer, controls, arcadeMachine, screenTexture;
        let zgsSystem = null;
        let isRunning = false;
        let currentCartridge = null;
        let activeKeys = new Set();
        let keyStates = { up: false, down: false, left: false, right: false };

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 1.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize OrbitControls (now guaranteed to be available)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.2, 0);
            controls.minDistance = 1.0;  // Prevent zooming too close
            controls.maxDistance = 5.0;  // Prevent zooming too far
            controls.maxPolarAngle = Math.PI * 0.8; // Limit vertical rotation
            console.log('‚úÖ OrbitControls initialized successfully');

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0x00ff88, 1, 10, Math.PI / 4, 0.5);
            spotLight.position.set(0, 4, 2);
            spotLight.castShadow = true;
            scene.add(spotLight);

            // Enhanced screen glow system (made more visible)
            const screenLight = new THREE.PointLight(0x4488ff, 1.2, 5);
            screenLight.position.set(0, 1.3, 0.4);
            scene.add(screenLight);
            
            // Additional subtle screen lights for better glow
            const screenGlow1 = new THREE.PointLight(0x6699ff, 0.8, 3);
            screenGlow1.position.set(0, 1.3, 0.35);
            scene.add(screenGlow1);
            
            const screenGlow2 = new THREE.PointLight(0x88aaff, 0.5, 2);
            screenGlow2.position.set(0, 1.3, 0.32);
            scene.add(screenGlow2);
            
            // Store lights for animation
            window.screenLights = [screenLight, screenGlow1, screenGlow2];

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            window.addEventListener('resize', onWindowResize, false);
        }

        // Create arcade machine
        function createArcadeMachine() {
            arcadeMachine = new THREE.Group();

            // Main cabinet
            const cabinetGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.6);
            const cabinetMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
            cabinet.position.y = 0.9;
            cabinet.castShadow = true;
            arcadeMachine.add(cabinet);

            // Screen bezel
            const bezelGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.05);
            const bezelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const bezel = new THREE.Mesh(bezelGeometry, bezelMaterial);
            bezel.position.set(0, 1.3, 0.3);
            arcadeMachine.add(bezel);

            // Screen texture
            const screenData = new Uint8Array(320 * 240 * 4);
            for (let i = 0; i < screenData.length; i += 4) {
                screenData[i] = 0; screenData[i + 1] = 0; screenData[i + 2] = 64; screenData[i + 3] = 255;
            }

            screenTexture = new THREE.DataTexture(screenData, 320, 240, THREE.RGBAFormat);
            screenTexture.flipY = true;
            screenTexture.magFilter = THREE.NearestFilter;
            screenTexture.minFilter = THREE.NearestFilter;

            // Screen
            const screenGeometry = new THREE.PlaneGeometry(0.4, 0.3);
            const screenMaterial = new THREE.MeshBasicMaterial({ 
                map: screenTexture
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 1.3, 0.325);
            arcadeMachine.add(screen);
            
            // Add visible screen glow halo (increased visibility)
            const glowGeometry = new THREE.PlaneGeometry(0.6, 0.45);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending
            });
            const screenGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            screenGlow.position.set(0, 1.3, 0.32);
            arcadeMachine.add(screenGlow);
            
            // Add inner glow ring
            const innerGlowGeometry = new THREE.PlaneGeometry(0.5, 0.38);
            const innerGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x6699ff,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
            innerGlow.position.set(0, 1.3, 0.323);
            arcadeMachine.add(innerGlow);
            
            // Store glow elements for animation
            window.screenGlowElements = [screenGlow, innerGlow];

            // Control panel
            const controlGeometry = new THREE.BoxGeometry(0.7, 0.1, 0.3);
            const controlMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const controlPanel = new THREE.Mesh(controlGeometry, controlMaterial);
            controlPanel.position.set(0, 1.0, 0.15);
            controlPanel.rotation.x = -0.2;
            arcadeMachine.add(controlPanel);

            // Joystick
            const stickGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.15);
            const stickMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const joystick = new THREE.Mesh(stickGeometry, stickMaterial);
            joystick.position.set(-0.15, 1.12, 0.05);
            arcadeMachine.add(joystick);

            // Buttons
            const buttonGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.02);
            const buttonMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            
            for (let i = 0; i < 6; i++) {
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(0.05 + (i % 3) * 0.08, 1.08, 0.05 + Math.floor(i / 3) * 0.08);
                arcadeMachine.add(button);
            }

            // Marquee
            const marqueeGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.03);
            const marqueeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff88 });
            const marquee = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
            marquee.position.set(0, 1.7, 0.3);
            arcadeMachine.add(marquee);

            scene.add(arcadeMachine);
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            // Update ZGS if running
            if (isRunning && zgsSystem) {
                try {
                    // Send current input state to game
                    if (currentCartridge === 'hambert') {
                        zgsSystem.handleInput(keyStates.up, keyStates.down, keyStates.left, keyStates.right);
                    }
                    
                    const frameReady = zgsSystem.stepFrame();
                    if (frameReady) {
                        zgsSystem.render();
                        
                        // Update 3D screen texture with ZGS output
                        const buffer = zgsSystem.get_screen_buffer();
                        if (buffer && screenTexture) {
                            screenTexture.image.data = new Uint8Array(buffer);
                            screenTexture.needsUpdate = true;
                        }
                    }
                } catch (error) {
                    console.error('Game loop error:', error);
                }
            } else if (screenTexture && !isRunning) {
                // Show test pattern when not running
                const data = screenTexture.image.data;
                const time = Date.now() * 0.005;
                
                for (let i = 0; i < data.length; i += 4) {
                    const x = (i / 4) % 320;
                    const y = Math.floor((i / 4) / 320);
                    
                    // Create a slow moving pattern
                    const r = Math.sin(x * 0.02 + time) * 60 + 40;
                    const g = Math.sin(y * 0.02 + time * 1.1) * 60 + 40;
                    const b = Math.sin((x + y) * 0.01 + time * 0.8) * 60 + 80;
                    
                    data[i] = r;     // R
                    data[i + 1] = g; // G
                    data[i + 2] = b; // B
                    data[i + 3] = 255; // A
                }
                
                screenTexture.needsUpdate = true;
            }

            // Animate screen glow effect (more visible)
            const time = Date.now() * 0.001;
            if (window.screenLights) {
                // More visible pulsing of screen lights
                const pulse = Math.sin(time * 2) * 0.2 + 1;
                window.screenLights[0].intensity = 1.2 * pulse;
                window.screenLights[1].intensity = 0.8 * pulse;
                window.screenLights[2].intensity = 0.5 * pulse;
            }
            
            if (window.screenGlowElements) {
                // More visible opacity animation for glow halos
                const glowPulse = Math.sin(time * 1.5) * 0.1 + 1;
                window.screenGlowElements[0].material.opacity = 0.25 * glowPulse;
                window.screenGlowElements[1].material.opacity = 0.3 * glowPulse;
            }

            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        // Event handlers
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Initialize ZGS system
        async function initializeZGS() {
            try {
                updateStatus('Waiting for ZGS module...');
                
                // Wait for the ZGS module to load
                let retries = 0;
                while (!window.zgsModuleLoaded && retries < 50) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    retries++;
                }
                
                if (!window.createZGSSystem) {
                    throw new Error('ZGS module failed to load');
                }
                
                updateStatus('Initializing ZGS system...');
                zgsSystem = await window.createZGSSystem();
                updateStatus('ZGS system ready - Load a cartridge');
                console.log('‚úÖ ZGS system initialized');
            } catch (error) {
                console.error('‚ùå Failed to initialize ZGS:', error);
                updateStatus('Failed to initialize ZGS system');
            }
        }

        // Button functions (these will be global)
        async function loadHambert() {
            if (!zgsSystem) {
                updateStatus('ZGS system not ready');
                return;
            }
            try {
                updateStatus('Loading Hambert cartridge...');
                const success = zgsSystem.loadHambertCartridge();
                if (success) {
                    currentCartridge = 'hambert';
                    updateStatus('Hambert loaded - Press Start to play!');
                } else {
                    updateStatus('Failed to load Hambert cartridge');
                }
            } catch (error) {
                console.error('‚ùå Error loading Hambert:', error);
                updateStatus('Error loading cartridge');
            }
        }

        async function loadZSynth() {
            if (!zgsSystem) {
                updateStatus('ZGS system not ready');
                return;
            }
            try {
                updateStatus('Loading Z-Synth cartridge...');
                const success = zgsSystem.loadZSynthCartridge();
                if (success) {
                    currentCartridge = 'zsynth';
                    updateStatus('Z-Synth loaded - Press Start to play!');
                } else {
                    updateStatus('Failed to load Z-Synth cartridge');
                }
            } catch (error) {
                console.error('‚ùå Error loading Z-Synth:', error);
                updateStatus('Error loading cartridge');
            }
        }

        async function startGame() {
            if (!zgsSystem || isRunning) return;
            try {
                updateStatus('Starting game...');
                await zgsSystem.start();
                isRunning = true;
                updateStatus(`Playing ${currentCartridge || 'game'} on 3D arcade!`);
            } catch (error) {
                console.error('‚ùå Failed to start game:', error);
                updateStatus('Failed to start game');
            }
        }

        function stopGame() {
            if (zgsSystem) {
                zgsSystem.stop();
            }
            isRunning = false;
            updateStatus('Game stopped');
            activeKeys.clear();
        }

        function resetGame() {
            if (zgsSystem) {
                zgsSystem.reset();
                updateStatus('Game reset');
            }
        }

        // Keyboard handling for game controls
        document.addEventListener('keydown', (event) => {
            if (currentCartridge === 'hambert' && isRunning) {
                switch(event.key) {
                    case 'ArrowUp':
                        keyStates.up = true;
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                        keyStates.down = true;
                        event.preventDefault();
                        break;
                    case 'ArrowLeft':
                        keyStates.left = true;
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                        keyStates.right = true;
                        event.preventDefault();
                        break;
                }
            }
            
            // Z-Synth controls
            const synthKeys = 'zsxdcvgbhnjm';
            const key = event.key.toLowerCase();
            if (synthKeys.includes(key) && currentCartridge === 'zsynth' && isRunning) {
                if (!activeKeys.has(key)) {
                    activeKeys.add(key);
                    if (zgsSystem) zgsSystem.handleZSynthKeyDown(key);
                }
                event.preventDefault();
            }
        });

        document.addEventListener('keyup', (event) => {
            if (currentCartridge === 'hambert' && isRunning) {
                switch(event.key) {
                    case 'ArrowUp':
                        keyStates.up = false;
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                        keyStates.down = false;
                        event.preventDefault();
                        break;
                    case 'ArrowLeft':
                        keyStates.left = false;
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                        keyStates.right = false;
                        event.preventDefault();
                        break;
                }
            }
            
            // Z-Synth controls
            const synthKeys = 'zsxdcvgbhnjm';
            const key = event.key.toLowerCase();
            if (synthKeys.includes(key) && currentCartridge === 'zsynth' && isRunning) {
                if (activeKeys.has(key)) {
                    activeKeys.delete(key);
                    if (zgsSystem) zgsSystem.handleZSynthKeyUp(key);
                }
                event.preventDefault();
            }
        });

        // Initialize everything when page loads
        window.addEventListener('load', async function() {
            updateStatus('Initializing 3D arcade...');
            initThreeJS();
            createArcadeMachine();
            animate();
            
            // Wait a moment for Three.js to settle, then initialize ZGS
            setTimeout(async () => {
                await initializeZGS();
            }, 1000);
        });
    </script>
</body>
</html>